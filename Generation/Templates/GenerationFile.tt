<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\netcoreapp3.1\Koko.RunTimeGui.dll" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Koko.RunTimeGui" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Globalization" #>

//dev env fix https://stackoverflow.com/questions/51550265/t4-template-could-not-load-file-or-assembly-system-runtime-version-4-2-0-0
//<dependentAssembly>
//<assemblyIdentity name="System.Runtime" publicKeyToken="b03f5f7f11d50a3a" culture="neutral"/>
//<bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="4.0.0.0"/>
//</dependentAssembly>

using Koko.RunTimeGui.Gui.Initable_Components;
using Koko.RunTimeGui;
using Microsoft.Xna.Framework;

namespace Koko.Generated { 

<#
	string name = "Menu";

	EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host).GetService(typeof(EnvDTE.DTE));

	var xmlPath = dte.ActiveDocument.Path + "..\\..\\..\\BOC_Editor\\XML";
	var files = GetAllXmlFiles(xmlPath);

	foreach(var file in files) {
		name = System.IO.Path.GetFileNameWithoutExtension(file).Replace(" ", "_");
		var path = System.IO.Path.Combine(file);
		XmlDocument doc = new XmlDocument();
		doc.Load(path);
#>
	public class Generate<#=name#> : IInitable {

		private IParent component = GUI.Gui;
		private BaseComponent temp;

		public void Init() {
			<# GetElementAndRecursiveOverChildren("/GUI", doc);#>
		}
	}
<#}#>
}

<#+
void GetElementAndRecursiveOverChildren(string currentPath, XmlDocument doc) {
	foreach (XmlNode node in doc.SelectNodes(currentPath + "/*")) {
		var foundnodes = node.ChildNodes.OfType<XmlElement>().Any();
		XmlAttributeCollection attributes = node.Attributes;
		if (foundnodes) {

			#> component = new <#=node.Name#>() {Parent = component, <#+SetValueBasedOnAttribute(attributes);#>}; <#+
			GetElementAndRecursiveOverChildren(currentPath + "/"+node.Name, doc);

			#>
			((BaseComponent)component).Parent.AddChild((BaseComponent)component);
			component = ((BaseComponent)component).Parent;
			<#+

		} else {
			#> temp = new <#=node.Name#>() {Parent = component, <#+
				SetValueBasedOnAttribute(attributes);
			#>};
			temp.Text = "<#=((XmlElement)node).InnerText #>";
			<#+
			#> component.AddChild(temp); <#+
		}
	}
}

void SetValueBasedOnAttribute(XmlAttributeCollection attrs) {
	foreach(XmlAttribute attr in attrs) {
		switch (attr.Name) {
			case "Margin":
				#>MarginalSpace = new Margin(<#=attr.Value#>),<#+
				break;
			case "Border":
				#>BorderSpace = new Margin(<#=attr.Value#>),<#+
				break;
			case "BackGroundColor":
				#>BackgroundColor = <#=GetBackgroundVal(attr.Value)#>,<#+
				break;
			case "Columns":
				#>Columns = <#=(GetIntergerValue(attr.Value) == 0) ? 2 : attr.Value#>,<#+
				break;
			case "IsDraggable":
				#>IsDraggable = <#=GetBooleanAttribute(attr.Value).ToString().ToLower()#>,<#+
				break;
			default:
				break;
		}
	}
}

private List<String> GetAllXmlFiles(string targetDirectory) {
    var files = new List<String>();
    foreach (string fileName in Directory.EnumerateFiles(targetDirectory, "*.xml", SearchOption.AllDirectories)) {
        files.Add(fileName);
    }
    return files;
}

private string GetBackgroundVal(string background) {
    if (background.StartsWith("#")) {
        var rx = new Regex(@"^#(?<alpha>[0-9a-f]{2})?(?<red>[0-9a-f]{2})(?<green>[0-9a-f]{2})(?<blue>[0-9a-f]{2})$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
        var groups = rx.Matches(background)[0].Groups;
        var alpha = byte.Parse(groups[1].Value != "" ? groups[1].Value : "ff", NumberStyles.HexNumber);
        var red = byte.Parse(groups[2].Value, NumberStyles.HexNumber);
        var green = byte.Parse(groups[3].Value, NumberStyles.HexNumber);
        var blue = byte.Parse(groups[4].Value, NumberStyles.HexNumber);
        return $"new Color({red}, {green}, {blue}, {alpha})";
    } else {
        return "Color." + background;
    }
}

private bool GetBooleanAttribute(string value) {
    value = value.ToLower();
    if (value == "yes" || value == "true" || value == "1")  return true;
    if (value == "no" || value == "false" || value == "0") return false;

    throw new ArgumentOutOfRangeException($"Don't know what to do with value '{value}' for boolean attribute");
}

private int GetIntergerValue(string margin) {
    if (margin != null) {
        try {
            return Int32.Parse(margin);
        } catch (FormatException e) {
            Console.WriteLine(e.Message);
        }
    }
    return 0;
}
#>