<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\netcoreapp3.1\Koko.RunTimeGui.dll" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Koko.RunTimeGui" #>
<#@ import namespace="System.Collections.Generic" #>

//dev env fix https://stackoverflow.com/questions/51550265/t4-template-could-not-load-file-or-assembly-system-runtime-version-4-2-0-0
//<dependentAssembly>
//<assemblyIdentity name="System.Runtime" publicKeyToken="b03f5f7f11d50a3a" culture="neutral"/>
//<bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="4.0.0.0"/>
//</dependentAssembly>

using Koko.RunTimeGui.Gui.Initable_Components;
using Koko.RunTimeGui;

namespace Koko.Generated { 

<#
	string name = "Menu";

	EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host).GetService(typeof(EnvDTE.DTE));

	var xmlPath = dte.ActiveDocument.Path + "..\\..\\..\\BOC_Editor\\XML";
	var files = GetAllXmlFiles(xmlPath);

	foreach(var file in files) {
		name = System.IO.Path.GetFileNameWithoutExtension(file).Replace(" ", "_");
		var path = System.IO.Path.Combine(file);
		XmlDocument doc = new XmlDocument();
		doc.Load(path);
#>
	public class Generate<#=name#> : IInitable {

		private IParent component = GUI.Gui;
		private BaseComponent temp;

		public void Init() {
			<# GetElementAndRecursiveOverChildren("/GUI", doc);#>
		}
	}
<#}#>
}

<#+
void GetElementAndRecursiveOverChildren(string currentPath, XmlDocument doc) {
	foreach (XmlNode node in doc.SelectNodes(currentPath + "/*")) {
		var foundnodes = node.ChildNodes.OfType<XmlElement>().Any();
		XmlAttributeCollection attributes = node.Attributes;
		if (foundnodes) {

			#> component = new <#=node.Name#>() {Parent = component, <#+SetValueBasedOnAttribute(attributes);#>}; <#+
			GetElementAndRecursiveOverChildren(currentPath + "/"+node.Name, doc);

			#>
			((BaseComponent)component).Parent.AddChild((BaseComponent)component);
			component = ((BaseComponent)component).Parent;
			<#+

		} else {
			#> temp = new <#=node.Name#>() {Parent = component, <#+
				SetValueBasedOnAttribute(attributes);
			#>};
			temp.Text = "<#=((XmlElement)node).InnerText #>";
			<#+
			#> component.AddChild(temp); <#+
		}
	}
}

void SetValueBasedOnAttribute(XmlAttributeCollection attrs) {
	foreach(XmlAttribute attr in attrs) {
		switch (attr.Name) {
			case "Margin":
				#>MarginalSpace = new Margin(<#=attr.Value#>),<#+
				break;
			case "Border":
				#>BorderSpace = new Margin(<#=attr.Value#>),<#+
				break;
			default:
				break;
		}
	}
}

private List<String> GetAllXmlFiles(string targetDirectory) {
    var files = new List<String>();
    foreach (string fileName in Directory.EnumerateFiles(targetDirectory, "*.xml", SearchOption.AllDirectories)) {
        files.Add(fileName);
    }
    return files;
}
#>