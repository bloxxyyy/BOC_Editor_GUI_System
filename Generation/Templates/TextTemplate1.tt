<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="$(SolutionDir)\bin\Debug\netcoreapp3.1\Koko.RunTimeGui.dll" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Koko.RunTimeGui" #>
<#@ import namespace="System.Collections.Generic" #>

<#
	EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host).GetService(typeof(EnvDTE.DTE));
	var path = System.IO.Path.Combine(dte.ActiveDocument.Path, "..\\..\\..\\BOC_Editor\\XML\\Menu.xml");
	XmlDocument doc = new XmlDocument();
	doc.Load(path);
#>//dev env fix https://stackoverflow.com/questions/51550265/t4-template-could-not-load-file-or-assembly-system-runtime-version-4-2-0-0
//<dependentAssembly>
//<assemblyIdentity name="System.Runtime" publicKeyToken="b03f5f7f11d50a3a" culture="neutral"/>
//<bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="4.0.0.0"/>
//</dependentAssembly>

using Koko.RunTimeGui.Gui.Initable_Components;
using Koko.RunTimeGui;

namespace Koko.RuntimeGui { 
	public class Generate : IInitable {

		private IParent component = GUI.Gui;
		private BaseComponent temp;

		public void Init() {
			<# GetElementAndRecursiveOverChildren("//GUI", doc);#>
		}
	}
}

<#+
void GetElementAndRecursiveOverChildren(string currentPath, XmlDocument doc) {
	var path = currentPath;

	#>

	//"<#=path#>"

	<#+


	foreach (XmlNode node in doc.SelectNodes(path + "//*")) {
		var foundnodes = node.ChildNodes.OfType<XmlElement>().Any();
		XmlAttributeCollection attributes = node.Attributes;

		if (foundnodes) {
			#> component = new <#=node.Name#>() {Parent = component, <#+
				SetValueBasedOnAttribute(attributes);
			#>}; <#+

			GetElementAndRecursiveOverChildren(path + "//"+node.Name, doc);

			#>
			((BaseComponent)component).Parent.AddChild((BaseComponent)component);
			component = ((BaseComponent)component).Parent;
			<#+

        } else {
			#> temp = new <#=node.Name#>() {Parent = component, <#+
				SetValueBasedOnAttribute(attributes);
			#>}; <#+
			#> component.AddChild(temp); <#+
		}
	}
}

void SetValueBasedOnAttribute(XmlAttributeCollection attrs) {
	foreach(XmlAttribute attr in attrs) {
		switch (attr.Name) {
			case "Margin":
				#>MarginalSpace = new Margin(<#=attr.Value#>),<#+
				break;
			case "Border":
				#>BorderSpace = new Margin(<#=attr.Value#>),<#+
				break;
			default:
				break;
		}
	}
}
#>